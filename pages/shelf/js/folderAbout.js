import {goToLounage} from '@/common/js/common-fn.js';
import {handle2List, handle2FileObj, handleManager} from '@/common/js/fileSystemAPI.js';
import {copyString, getMediaDuration} from '@/common/js/pure-fn.js';
import {fillOneFile} from '@/common/js/fs-fn.js';

const sqlite = await useSqlite();

const oFn01 = {
    // ‚ñºÂà†Èô§‰∏ÄÈ°πÔºàÂæÖÈ™åËØÅÔºâ
    async toForgetMedia(oMedia){
        const {id} = oMedia;
        // console.log(oMedia.$dc());
        const confirm = await ElMessageBox.confirm(
            'Á°ÆËÆ§ÁßªÈô§ËÆ∞ÂΩï?',
            'ËØ∑Á°ÆËÆ§',
            {
                confirmButtonText: 'Á°ÆËÆ§ÁßªÈô§',
                cancelButtonText: 'ÂèñÊ∂à',
                type: 'warning',
            }
        ).catch(xx=>xx);
        console.log("answer:", confirm);
        if (confirm != 'confirm') return;
        sqlite.run(`DELETE FROM action WHERE mediaId=${id};`),
        sqlite.run(`DELETE FROM new_word WHERE mediaId=${id};`),
        sqlite.run(`DELETE FROM line WHERE mediaId=${id};`),
        sqlite.run(`DELETE FROM media WHERE id=${id};`);
        this.ckickItem(...this.aLastFolder);
    },
    // ‚ñºÂ¶ÇÊûúÊñá‰ª∂ÂêçÔºå‰ΩìÁßØÔºå‰øÆÊîπÊó∂Èó¥ÂèòÂåñ‰∫ÜÔºåÊ≠§ÊñπÊ≥ïÁî®‰∫éËÆ∞ÂΩïÊñ∞ÁöÑ‰ø°ÊÅØÂà∞Êï∞ÊçÆÂ∫ì
    async updateMediaInfo(){
        let aLast = this.aDirectory.at(-1);
        aLast = aLast.filter(cur => {
            return cur?.infoAtDb?.id && !cur.bNameRight;
        });
        console.log("Wrong list\n", aLast);
        for await (let [idx, val] of aLast.entries()){
            const {infoAtDb, oFile} = val;
            const oDuration = await getMediaDuration(oFile);
            sqlite.tb.media.updateOne({
                id: infoAtDb.id,
                name: oFile.name,
                size: oFile.size,
                ...oDuration,
            });
            ElMessage.success(`Êñá‰ª∂‰ø°ÊÅØÊõ¥Êñ∞ÂÆåÊàêÔºö${oFile.name}`);
        }
        this.ckickItem(...this.aLastFolder);
    },
    // ‚Üì Â∞ÜÂ™í‰ΩìÈÖçÂØπÔºàÊú™ÂÆåÂÖ®ÂÆåÊàêÔºâ
    switchMp3(){
        let aLast = this.aDirectory.at(-1);
        if (!aLast?.length) return;
        this.oFileChanging.isShowDialog = true;
        let aItemsOld = [];
        const oMatched = {};
        aLast.forEach(oCur => {
            if (!oCur.isMedia) return;
            let [sNameShorten, sTail] = oCur.name.split(/\.(?=[a-z0-9]{2,5}$)/i);
            sTail &&= sTail.toLowerCase();
            oCur.sNameShorten = sNameShorten;
            const usable = !oCur.infoAtDb && ['ogg'].includes(sTail);
            if (sTail === 'mp3' && oCur.infoAtDb){
                aItemsOld.push(oCur);
            }else if(usable){
                oMatched[sNameShorten] ||= [];
                oMatched[sNameShorten].push(oCur);
                getMediaDuration(oCur.oFile).then(oDuration => {
                    Object.assign(oCur, oDuration);
                });
            }
        }, {});
        aItemsOld = aItemsOld.filter(oMedia => {
            oMedia.aMatched = oMatched[oMedia.sNameShorten];
            return oMedia.aMatched;
        });
        this.oFileChanging.aListMatched = aItemsOld;
        console.log("aItemsOld\n", aItemsOld.$dc());
    },
    // ‚Üì ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
    async changeMediaFile(oNewMedia, idx){
        if (!oNewMedia.hash) return;
        const oOld = this.oFileChanging.aListMatched[idx];
        if (oOld.changingMark) return;
        const oDuration = await getMediaDuration(oNewMedia.oFile);
        console.log("old, new\n", oOld.$dc(), '\n', oNewMedia.$dc());
        const oNewInfo = {
            id: oOld.infoAtDb.id,
            dir: oNewMedia.path,
            name: oNewMedia.name,
            size: oNewMedia.size,
            hash: oNewMedia.hash,
            ...oDuration,
        };
        sqlite.tb.media.updateOne(oNewInfo);
        console.log("oNewInfo\n", oNewInfo.$dc());
        oNewMedia.changingMark = '‚úî';
    },
}



const oFn02 = {
    copyHash(hash){
        const res = copyString(hash);
        if (!res) return;
        this.hashCopied = hash;
        ElMessage.success(`Â∑≤Â§çÂà∂ ${hash}`);
    },
    // ‚Üì Ê∑ªÂä†‰∏Ä‰∏™Ê†πÁõÆÂΩï
    async chooseRoot(){
        let handle = await window.showDirectoryPicker({
            mode: 'readwrite',
        }).catch(err => {});
        if (!handle) return;
        const createdAt = dayjs().format('YYYY-MM-DD HH:mm:ss');
        const path = `${createdAt}`;
        await dxDB.directory.add({
            name: handle.name,
            handle,
            path,
            createdAt, // ÂΩìÂîØ‰∏ÄÈîÆ‰ΩøÁî®
        });
        this.showRootList();
        const arr = await handle2List(handle, {path});
        this.aDirectory.splice(0, 1/0, arr);
        fillTheList(this.aDirectory[0]);
    },
    async showRootList(){
        const aRoots = await dxDB.directory.toArray();
        // console.log("aRoots", aRoots);
        this.aRoots = aRoots || [];
        // ‚Üì ÊâæÂà∞ÊúâÊùÉÈôêÁöÑÁõÆÂΩïÔºåÊòæÁ§∫Âá∫Êù•
        let hasFound;
        this.aRoots.forEach(async (cur, idx) => {
            const answer = await cur.handle.queryPermission();
            cur.permission = answer; // ËÆ∞ÂΩïËµ∑Êù•ÔºåÂ§áÁî® 
            if (answer == 'granted' && !hasFound){
                hasFound = true;
                cur.active = true;
                this.setRoot(idx);
            }
        });
    },
    deletRoot(idx){
        const {id, path} = this.aRoots[idx];
        this.aRoots.splice(idx, 1);
        dxDB.directory.delete(id);
        dxDB.file.where('pathFull').startsWith(path).delete();
    },
    // ‚ÜìÈÄâÊã©Ê†πÁõÆÂΩï
    async setRoot(idx){
        const {handle, path} = this.aRoots[idx];
        this.aRoots.forEach((cur, index)=>{
            cur.active = idx === index;
        });
        let answer = await handle.requestPermission({
            // mode: 'readwrite',
        });
        if (answer != 'granted') return;
        handleManager(handle);
        const aRoot = await handle2List(handle, {path});
        this.aDirectory.splice(0, Infinity, aRoot);
        fillTheList(this.aDirectory[0]);
    },
    // ‚Üì ÁÇπÂáªÊñá‰ª∂Â§π„ÄÅÊñá‰ª∂
    async ckickItem(i1, i2){
        const oItem = this.aDirectory[i1][i2];
        const {isMedia, dxID, hash, pathFull} = oItem;
        console.log(`ÁÇπÂáªÁõÆÊ†áÔºö\n`, oItem.$dc());
        if (isMedia) {
            if (hash) goToLounage(oItem);
            else console.log("Ê≥®ÊÑèÔºå‰∏çÂèØË∑≥ËΩ¨", );
            return;
        }
        if (oItem.kind !== 'directory') return;
        this.aLastFolder = [i1, i2];
        // üëàÂ§ÑÁêÜÁÇπÂáªÊñá‰ª∂Â§πÂä®‰Ωú
        // ‚ñº this.aPath Ê≠£Âú®Ë¢´ watch ÁõëÂê¨ÔºåÊìç‰Ωú‰ºöËß¶ÂèëÂêéÁª≠Âä®‰Ωú
        // this.aPath.splice(i1 + 1, Infinity, sItem);
        const arr = await handle2List(oItem.handle, {path: oItem.path});
        console.log("ÁõÆÊ†áÁöÑÂ≠êÂÖÉÁ¥†ÔºàÂàùÊ≠•Êï∞ÊçÆÔºâ\n", arr);
        this.aDirectory.splice(i1+1, Infinity, arr);
        fillTheList(this.aDirectory[i1+1]);
        this.aRoutesInt.splice(i1, 1/0, i2);
    },

    // ‚Üì ÂàáÊç¢Â™í‰ΩìÊñá‰ª∂
    async useAnotherMedia(oMedia){
        console.log(`ÁÇπÂáªÂàó\n`, oMedia.$dc());
        const {name, infoAtDb} = oMedia;
        const sTitle = `ËØ∑ËæìÂÖ•16‰ΩçÊñá‰ª∂ hash`;
        const sTip = `Ê≠£Âú®‰øÆÊîπÔºö${name}`;
        const oAnswer = await ElMessageBox.prompt(sTip, sTitle, {
            confirmButtonText: 'Á°ÆËÆ§',
            cancelButtonText: 'ÂèñÊ∂à',
        }).catch(err => {
            console.log("ÂèñÊ∂à‰∫Ü", err);
        });
        const value = oAnswer?.value || '';
        // hash : "9361db3653916c8a" // ‚Üê 16‰Ωç
        const [hash] = value.match(/^[0-9a-z]{16}$/i) || [];
        console.log("hash", hash);
        if (!hash || !infoAtDb.id) return;
        return alert('ÂÅúÊ≠¢ÔºåÈúÄË¶Å‰ºòÂåñ')
        const res = sqlite.tb.media.updateOne({
            id: infoAtDb.id,
            hash,
        });
        if (!res) return;
        this.ckickItem(...this.aLastFolder);
        // ‰ªé dxDB ‰∏≠ÁßªÊàñ‰øÆÊîπËÆ∞ÂΩï
    },
};


// ‚Üì ‰∏ìÈó®Â§ÑÁêÜÂ™í‰ΩìÊ∞îÊ≥°
const oMediaPopper = {
    // üëáÂÖâÊ†áÂÅú‰∫éÊñá‰ª∂‰∏äÊñπ
    hoverIn(ev, oTarget){
        if (!oTarget.isMedia) return; 
        this.mediaPopperToggle(true);
        const {duration} = oTarget;
        const iMBLong = (()=>{
            if (!duration) return 0;
            return 1 * (duration / 60 / oTarget.sizeMB).toFixed(1);
        })();
        const sStarts = (()=>{
            if (iMBLong < 1) return '‚òÜ';
            let sResult = '‚òÖ'.repeat(iMBLong);
            if (iMBLong % 1 >= 0.5) sResult += '‚òÜ';
            return sResult;
        })();
        this.oHoveringMedia = {
            ...oTarget,
            iMBLong,
            sStarts,
            dom: ev.target,
            show: true,
        };
    },
    // ‚Üì ÊéßÂà∂Ê∞îÊ≥°ÂèØÊÄßÊÄß 01
    mediaPopperToggle(isShow){
        clearTimeout(this.iHoverTimer);
        if (isShow) return;
        this.iHoverTimer = setTimeout(()=>{
            this.oHoveringMedia.show = false; // Áî®‰∫éÈöêËóèÊ∞îÊ≥°
        }, 300);
    },
    // ‚Üì ÊéßÂà∂Ê∞îÊ≥°ÂèØÊÄßÊÄß 02
    takePopperDOM(oPopper){
        const {contentRef} = oPopper?.popperRef || {};
        if (!contentRef) return;
        contentRef.onmouseenter = ()=>this.mediaPopperToggle(true);
        contentRef.onmouseleave = ()=>this.mediaPopperToggle(false);
    },
};


export default {
    ...oFn01,
    ...oFn02,
    ...oMediaPopper,
};

// ‰∏∫Êñá‰ª∂ÂàóË°®Â°´ÂÖÖÊñá‰ª∂‰ø°ÊÅØ
async function fillTheList(aList){
    if (!aList?.length) return;
    let index = 0;
    const config = {
        force: true,
        record: true,
    };
    for await (const [idx, cur] of aList.entries()){
        if (!cur.isMedia) continue;
        // if (!index) console.log('before filling:', cur.$dc());
        if (++index % 3 == 0) await fillOneFile(cur, config);
        else fillOneFile(cur, config);
    }
}


async function init() {
    const {initBackend} = await import('https://cdn.jsdelivr.net/npm/absurd-sql@0.0.54/dist/indexeddb-main-thread.js');
    let worker = new Worker(new URL('./absurd-sql-worker.js', import.meta.url));
    // This is only required because Safari doesn't support nested
    // workers. This installs a handler that will proxy creating web
    // workers through the main thread
    initBackend(worker);
    console.log(worker);
}

// const iLastDot = oCur.name.lastIndexOf('.');
// const sTail = oCur.name.slice(iLastDot + 1);
// const sNameShorten = oCur.name.slice(0, iLastDot);


// async function fillOneFile(oFileInfo){
//     const oPathFull = {pathFull: oFileInfo.pathFull};
//     const aPromise = await Promise.all([
//         handle2FileObj(oFileInfo.handle),
//         dxDB.file.where(oPathFull).first(),
//     ]);
//     let [oFileINfo, oFileInDx] = aPromise;
//     Object.assign(oFileInfo, oFileINfo);
//     if (!oFileINfo.isMedia) return;
//     let [hash, id] = (()=>{
//         if (!oFileInDx) return [];
//         const aa = oFileInfo.size == oFileInDx.size;
//         if (!aa || !bb) return [];
//         return [oFileInDx.hash, oFileInDx.id];
//     })();
//     // console.log("dxDB ‰∏≠ÁöÑ hash: ", hash || 'ÊöÇÊó†');
//     if (!hash){
//         let arrayBuffer = await oFileINfo.oFile.arrayBuffer();
//         let arrayData = new Uint8Array(arrayBuffer);
//         hash = await hashwasm.xxhash64(arrayData);
//         const createdAt = new Date();
//         dxDB.file.put({
//             hash,
//             createdAt,
//             updatedAt: createdAt,
//             ...oPathFull,
//             path: oFileInfo.pathFull.match(/.+(?=\/)/)[0],
//             size: oFileINfo.size,
//         }, oPathFull).then(iID => {
//             oFileInfo.dxID = iID;
//         });
//     }
//     Promise.resolve().then(()=>{
//         // console.time('Êü•ËØ¢hash ÂØπÂ∫îÁöÑÂ™í‰Ωì')
//         const res = sqlite.select(`select * from media where hash='${hash}'`);
//         // console.timeEnd('Êü•ËØ¢hash ÂØπÂ∫îÁöÑÂ™í‰Ωì')
//         if (!res?.[0]) return;
//         oFileInfo.infoAtDb = res[0];
//         oFileInfo.bNameRight = res[0].name === oFileInfo.name;
//     });
//     oFileInfo.hash = hash;
//     if(id) oFileInfo.dxID = id;
// }
