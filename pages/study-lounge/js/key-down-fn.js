/*
 * @Author: ÊùéÊòüÈò≥
 * @Date: 2021-02-19 16:35:07
 * @LastEditors: Merlin
 * @LastEditTime: 2024-01-16 22:07:42
 * @Description: 
 */
import { getCurrentInstance } from 'vue';
import { fixTime } from '../../../common/js/pure-fn.js';
import { figureOut } from './figure-out-region.js';
import TheAction from '@/common/js/action.js';
import {LineDB} from '@/database/line.js';
// import {useBarInfo} from '@/store/happy-bar.js';
// const oBarInfo = useBarInfo();
const oActionFn = new TheAction('reading');
let iSearchingQ = 0;
let isSavingToDB = false; //‰øùÂ≠ò‰∫ã‰ª∂Èò≤Êäñ
let sqlite = await useSqlite;

export function getKeyDownFnMap(This, sType) {
    const { oMyWave } = This;
    function playAndCheck(iVal){
        oMyWave.toPlay(iVal);
        This.setLeftLine();
    }
    function playOrMove(ev, iVal){
        const ScrollLock = ev.getModifierState("ScrollLock");
        if (ScrollLock) return playAndCheck(iVal);
        const iGoTo = iVal < 0 ? 0 : This.oTextArea.value.length;
        This.oTextArea.selectionStart = iGoTo;
        This.oTextArea.selectionEnd = iGoTo;
    }
    const withNothing = [
        { key: 'Home', name: '‰∏ä‰∏ÄÂè•', fn: ev => playOrMove(ev, -1)},
        { key: 'End', name: '‰∏ã‰∏ÄÂè•', fn: ev => playOrMove(ev, 1)},
        { key: 'Prior', name: '‰∏ä‰∏ÄÂè•', fn: () => This.previousAndNext(-1) },
        { key: 'Next', name: '‰∏ã‰∏ÄÂè•', fn: () => This.previousAndNext(1) },
        { key: 'Backslash', name: '‰∏ä‰∏ÄÂè•', fn: () => This.previousAndNext(-1) },
        { key: 'Enter', name: '‰∏ã‰∏ÄÂè•', fn: () => This.previousAndNext(1) },
        { key: 'w', name: '‰∏ä‰∏ÄÂè•', fn: () => This.previousAndNext(-1) },
        { key: 's', name: '‰∏ã‰∏ÄÂè•', fn: () => This.previousAndNext(1) },
        // ‚ñ≤Êç¢Ë°å
        { key: 'Tilde', name: 'Êí≠ÊîæÂêéÂçäÂè•', fn: () => oMyWave.toPlay(true) },
        { key: 'Tab', name: 'Êí≠ÊîæÂΩìÂâçÂè•', fn: () => playAndCheck() },
        { key: 'F1', name: 'ÊèíÂÖ•ÊñáÊú¨', fn: () => This.smartFill() },
        // { key: 'F1', name: 'ËÆæÂÆöËµ∑ÁÇπ', fn: () => This.cutHere('start') },
        { key: 'F2', name: 'ËÆæÂÆöÁªàÁÇπ', fn: () => This.cutHere('end') },
        { key: 'F3', name: 'ÊäõÂºÉÂΩìÂâçÂè•', fn: () => This.giveUpThisOne() },
        { key: 'F4', name: 'Êü•Â≠óÂÖ∏', fn: () => This.searchWord() },
        { key: 'Escape', name: 'ÂèñÊ∂àÊí≠Êîæ', fn: () => This.Esc() }, // ÂÅúÊ≠¢Êí≠Êîæ
        { key: 'Space', name: 'ÊúóËØª', fn: ev => This.readAloud(ev) }, // ÂÅúÊ≠¢Êí≠Êîæ
    ];
    const withCtrl = [
        { key: 'ctrl + Prior', name: '‰∏ä‰∏ÄÈ°π', fn: () => This.visitNeighbor(-1) },
        { key: 'ctrl + Next', name: '‰∏ã‰∏ÄÈ°π', fn: () => This.visitNeighbor(1) },
        { key: 'ctrl + q', name: 'Êü•Â≠óÂÖ∏', fn: () => This.searchWord() },
        { key: 'ctrl + b', name: 'ÊòæÁ§∫Â∑¶Ê†è', fn: () => This.showLeftColumn() },
        { key: 'ctrl + d', name: 'Âà†Èô§‰∏ÄË°å', fn: () => This.toDel() },
        { key: 'ctrl + z', name: 'Êí§ÈîÄ', fn: () => This.setHistory(-1) },
        { key: 'ctrl + s', name: '‰øùÂ≠òÂà∞DB', fn: () => This.saveLines() },
        { key: 'ctrl + j', name: 'ÂêàÂπ∂‰∏ä‰∏ÄÂè•', fn: () => This.putTogether(-1) },
        { key: 'ctrl + k', name: 'ÂêàÂπ∂‰∏ã‰∏ÄÂè•', fn: () => This.putTogether(1) },
        { key: 'ctrl + f', name: 'ÊúóËØª', fn: () => This.tts_reader() },
        { key: `ctrl + '`, name: 'Â§ÑÁêÜÂºïÂè∑', fn: () => This.dealQuotationMark() },
        // { key: 'ctrl + Enter', name: 'Êí≠Êîæ', fn: () => oMyWave.toPlay() }, // Â∞ÜÊù•ÂºÄÂèëÊ≠§ÊñπÊ≥ïËÉΩÊâìÈòÖËØªÊ†áËÆ∞
        // { key: 'ctrl + shift + Enter', name: 'Êí≠Êîæ', fn: () => oMyWave.toPlay(true) },
        { key: 'ctrl + shift + z', name: 'ÊÅ¢Â§ç', fn: () => This.setHistory(1) },
        { key: 'ctrl + shift + c', name: 'ÂàÜÂâ≤', fn: () => This.split() }, // ‰∏ÄÂàÄ‰∏§ÊÆµ
    ];
    const withAlt = [
        // ‰øÆÊîπÈÄâÂå∫
        { key: 'alt + ]', name: 'Êâ©ÈÄâ', fn: () => This.chooseMore() },
        { key: 'alt + c', name: 'Ëµ∑ÁÇπÂ∑¶Áßª', fn: () => This.fixRegion('start', -0.07) },
        { key: 'alt + v', name: 'Ëµ∑ÁÇπÂè≥Áßª', fn: () => This.fixRegion('start', 0.07) },
        { key: 'alt + n', name: 'ÁªàÁÇπÂ∑¶Áßª', fn: () => This.fixRegion('end', -0.07) },
        { key: 'alt + m', name: 'ÁªàÁÇπÂè≥Áßª', fn: () => This.fixRegion('end', 0.07) },
        // ÈÄâËØç
        { key: 'alt + a', name: 'ÊèíÂÖ•ÂÄôÈÄâËØç', fn: () => This.toInset(0) },
        { key: 'alt + s', name: 'ÊèíÂÖ•ÂÄôÈÄâËØç', fn: () => This.toInset(1) },
        { key: 'alt + d', name: 'ÊèíÂÖ•ÂÄôÈÄâËØç', fn: () => This.toInset(2) },
        // { key: 'alt + f', name: 'ÊèíÂÖ•ÂÄôÈÄâËØç', fn: () => This.toInset(3) },
        { key: 'alt + f', name: 'ÊèíÂÖ•ÊñáÊú¨', fn: () => This.smartFill() },
        // Êú™ÂàÜÁ±ª
        // { key: 'alt + j', name: '', fn: () => This.previousAndNext(-1) },
        // { key: 'alt + k', name: '', fn: () => This.previousAndNext(1) },
        { key: 'alt + j', name: '', fn: () => playAndCheck(-1) },
        { key: 'alt + k', name: '', fn: () => playAndCheck(1) },
        { key: 'alt + l', name: 'Ë∑≥Âà∞ÊúÄÂêé‰∏ÄÂè•', fn: () => This.goLastLine() },
        // { key: 'alt + q', name: 'Â∑¶‰æßÂÆö‰Ωç', fn: () => This.setLeftLine() },
        // alt + shift
        { key: 'alt + shift + j', name: 'Âêë„ÄêÂ∑¶„ÄëÊèíÂÖ•‰∏ÄÂè•', fn: () => This.toInsert(-1) },
        { key: 'alt + shift + k', name: 'Âêë„ÄêÂè≥„ÄëÊèíÂÖ•‰∏ÄÂè•', fn: () => This.toInsert(1) },
        { key: 'alt + shift + d', name: '‰øùÂ≠òÂçïËØçÂà∞‰∫ë', fn: () => This.saveWord() },
        { key: 'alt + shift + c', name: 'Êü•Â≠óÂÖ∏', fn: () => This.searchWord() },
    ];
    // ‚ñºÂ∞ÜÊù•Áî®‰∫éÂâçÁ´ØÊòæÁ§∫ÁªôÁî®Êà∑
    // if(0) return [withNothing, withCtrl, withAlt];
    const aFullFn = [...withNothing, ...withCtrl, ...withAlt];
    if (sType === 'obj') {
        return aFullFn.reduce((oResult, cur) => {
            oResult[cur.key] = cur.fn;
            return oResult;
        }, {});
    }
    return aFullFn;
}

// ‚ñºÊåâÈîÆÂêéÁöÑÊñπÊ≥ïÂàóË°®
export function fnAllKeydownFn() {
    const oInstance = getCurrentInstance();
    const This = oInstance.proxy;
    function Esc(){
        if (This.oMyWave.playing) {
            return This.oMyWave.toPause();
        }else{
            This.oTextArea.blur();
        }
    }
    async function tts_reader(){
        let text = This.oCurLine.text.trim();
        if (!text) return;
        await fetch('/api/send_text', {
            method: 'post',
            headers: { "Content-Type": "application/json"},
            body: JSON.stringify({
                text, announcer: 'Jenny',
            }),
        });
    }
    function readAloud(ev){
        // console.log(`ÈïøÊåâ ${ev.repeat} - ${This.isReading}`);
        // ÁªàÊ≠¢Êù°‰ª∂ üëâ ÈùûÈïøÊåâ || Â∑≤ËøõÂÖ•ÊúóËØªÁä∂ÊÄÅ
        // if (!ev.repeat || This.isReading) return;
        if (This.isReading) return;
        This.isReading = true;
        This.oMyWave.toPlay(null, ev);
        This.oCurLine.text = This.oCurLine.text.trim().replace(/\s{2,}/g, ' ');
        // oBarInfo.setStatus(true);
        console.log('ÂºÄÂßãÊúóËØª');
        oActionFn.initRecord({ // Âè™ÁÆ°ÂêØÂä®ÔºåÁ®ãÂ∫è‰ºöÊåâÈúÄ‰øùÂ≠ò
            mediaId: This.oMediaInfo.id,
            lineId: This.oCurLine.id || null, // Êñ≠Âè•ÊúüÈó¥ÂèØËÉΩÊ≤°Êúâ ID 
            playFrom: This.oCurLine.start,
            playEnd: This.oCurLine.end,
        });
    }
    function readingStopped(ev){
        if (!This.isReading) return;
        This.isReading = false;
        This.oMyWave.toPause();
        // console.log(`ÊùæÂºÄÁ©∫Ê†º ${This.isReading}`, ev);
        const iDuration = oActionFn.saveRecord();
        // oBarInfo.setStatus(false, iDuration);
        // console.log(`ÊúóËØªÂÆåÊàê ${duration} Áßí`, This.oReadingAloud.$dc());
    }
    function dealQuotationMark(){
        console.log('dealQuotationMark', This.oCurLine);
        let text = This.oCurLine.text.trim();
        if (!text) return;
        var aa = `"'`.includes(text.at(0));
        var bb = `"'`.includes(text.at(-1));
        if (aa || bb){ // ÊúâÂàôÂà†Èô§
            const iStart = aa ? 1 : 0;
            const iEnd = bb ? -1 : Infinity;
            This.oCurLine.text = text.slice(iStart, iEnd) + ' ';
        }else{ // Êó†ÂàôÊ∑ªÂä†ÔºàÂú®Â∑¶‰æßÂ§¥ÈÉ®Ê∑ªÂä†Ôºâ
            This.oCurLine.text = `"${text}`;
        }
    }
    function smartFill(){
        const {
            aArticle, oTopLineMatch, iWriting, sWriting,
            iMatchStart, iMatchEnd, iShowUntil, oCurLine,
        } = This;
        if (!oTopLineMatch && !sWriting) return;
        const {iLeftLine} = oTopLineMatch || {};
        let sCandidate = '';
        let aaa = iLeftLine >= 0 && (iWriting < 0 || (iWriting - iLeftLine >= 1));
        if (aaa){
            sCandidate = aArticle[iLeftLine].slice(oTopLineMatch.iMatchEnd);
            if (iLeftLine + 1 != iWriting){
                sCandidate += aArticle.slice(iLeftLine + 1, iWriting).join('\n');
            }
        }
        if(iWriting >= 0){
            const sGreen = sWriting.slice(iMatchStart, iMatchEnd);
            if (sGreen){
                sCandidate = sWriting.slice(iMatchEnd);
            }else if (iLeftLine == iWriting){
                sCandidate = sWriting.slice(oTopLineMatch.iMatchEnd, iMatchStart)
            }else{
                sCandidate = sWriting.slice(0, iMatchStart);
            }
            sCandidate += aArticle.slice(iWriting + 1).join('\n');
        } else{
            let iVal = Math.max(iShowUntil + 1, (iLeftLine - 1) || 0);
            sCandidate += aArticle.slice(iVal, iVal + 2).join('\n');
        }
        sCandidate = sCandidate.slice(0, 100).trim();
        let match = sCandidate.match(/^\W{1,4}\s+(?=\S)/);
        if (match){
            sCandidate = sCandidate.slice(match[0].length);
        }
        // let sFirst = sCandidate.match(/(\S+\s+){3}/)[0] + ' ';
        // let sFirst = sCandidate.match(/(\S+\s{0,1}){1,3}/)[0] + ' ';
        let sFirst = sCandidate.match(/(\S+\s{0,1}){1,3}/)[0] + ' ';
        let iFind = sFirst.search(/[,"'!\.\?\n]\s/);
        if (iFind > -1) {
            // console.log('iFind', iFind, sCandidate);
            sFirst = sFirst.slice(0, iFind + 2);
        }
        // sFirst = sFirst.match(/.+([\.,!\?]|.)/)[0];
        oCurLine.text = (oCurLine.text + '' + sFirst).replace(/\s{2,}|\n|\r/g, ' ');
        setLeftLine();
        recordHistory();
        // console.log('oTopLineMatch', oTopLineMatch?.$dc(), '\n\n');
        // console.log(sCandidate);
    }
    // ‚ñºÂàáÊç¢ÂΩìÂâçÂè•Â≠êÔºà‰∏ä‰∏ÄÂè•Ôºå‰∏ã‰∏ÄÂè•Ôºâ
    function previousAndNext(iDirection) {
        const { oMediaBuffer, aLineArr, iCurLineIdx } = This;
        const iCurLineNew = iCurLineIdx + iDirection;
        if (iCurLineNew < 0) {
            return ElMessage.warning('Ê≤°Êúâ‰∏ä‰∏ÄË°å');
        }else if (!oMediaBuffer.duration && !aLineArr.length){
            return ElMessage.warning('ÊöÇÊó†Ê≥¢ÂΩ¢Êï∞ÊçÆÔºåËØ∑Á≠âÂæÖ');
        }
        const oNewLine = (() => {
            if (aLineArr[iCurLineNew]) return false; //ÊúâÊï∞ÊçÆÔºå‰∏çÊñ∞Â¢û
            if ((oMediaBuffer.duration - aLineArr[iCurLineIdx].end) < 0.3) {
                return null; //‰∏¥ËøëÁªàÁÇπÔºå‰∏çÊñ∞Â¢û
            }
            const { end } = aLineArr[aLineArr.length - 1];
            return figureOut(oMediaBuffer, end); // Ë¶ÅÊñ∞Â¢û‰∏ÄË°åÔºåËøîÂõû‰∏ãË°åÊï∞ÊçÆ
        })();
        if (oNewLine === null) {
            return ElMessage.warning('ÂêéÈù¢Ê≤°Êúâ‰∫Ü');
        }
        goLine(iCurLineNew, oNewLine, true);
    }
    // ‚ñºË∑≥Ëá≥ÊüêË°å
    async function goLine(iAimLine, oNewLine, toRecord) {
        setLeftLine(); // ‚òÖÂéªÊñ∞‰∏ÄË°å‰πãÂâçÂÆö‰Ωç
        if (oNewLine) This.aLineArr.push(oNewLine);
        const {iCurLineIdx: iOldLine} = This;
        iAimLine ??= iOldLine;
        iAimLine = Math.min(iAimLine, This.aLineArr.length - 1); // Èò≤Ê≠¢Ë∂äÁïå
        This.iCurLineIdx = iAimLine;
        let isGoingUp = iAimLine < iOldLine;
        // let goOneStep = iAimLine - iOldLine == 1;
        // goOneStep && showAchievement(iOldLine, iAimLine);
        setLinePosition(iAimLine);
        setLeftLine(); // ‚òÖ Âà∞Êñ∞‰∏ÄË°å‰πãÂêéÂÆö‰Ωç
        recordPlace(iAimLine)
        if (toRecord) recordHistory();
        if (isGoingUp) return; // Â¶ÇÊûúË°åÂè∑Âú®ÂèòÂ∞è return
        let iCount = 0;
        for (const cur of This.aLineArr){
            This.checkIfChanged(cur) && iCount++;
            if (iCount <= 2) continue;
            return This.saveLines(); // ‰øùÂ≠ò
        }
    }
    // ‚ñºÂºπÂá∫ÊèêÁ§∫ÔºàÊàêÂ∞±Ôºâ
    // async function showAchievement(iOldLine, iAimLine){
    //     vm.$message(`${iOldLine} > ${iAimLine}`);
    // }
    // ‚ñºËÆ∞ÂΩïÂΩìÂâçÊñá‰ª∂ËøõË°åÂà∞Âì™‰∏ÄË°å‰∫Ü
    async function recordPlace(iAimLine){ // Áî®ÂºÇÊ≠•ÊñπÊ≥ïÈò≤Ê≠¢ÈòªÊñ≠‰∏ªËøõÁ®ã
        // ËÄÉËôëÊ∑ªÂä†Ôºö1‰∏™Âª∂Êó∂‰∏éÈò≤Êäñ
        const iAll = This.aLineArr.length;
        if (!This.oCurLine) return;
        let {end, start_} = This.oCurLine;
        const {dir, name, duration, durationStr} = This.oMediaInfo;
        const fPercent = (()=>{
            let fResult = This.iCurLineIdx / iAll;
            if (duration) fResult = end / duration;
            return (fResult * 100).toFixed(2) * 1;
        })();
        start_ = start_.slice(0,-3).padStart(8,0);
        store.transact('oRecent', (oldData) => {
            const {pathFull} = store('media');
            const old = oldData[pathFull] || {
                startAt: new Date() * 1, // ËÆ∞ÂΩïÂºÄÂßãÊó∂Èó¥
            };
            oldData[pathFull] = {
                ...old,
                dir,
                name,
                iTime: new Date()* 1, // ÊàñËÆ∏ updatedAt Ëøô‰∏™ÈîÆÂêçÊõ¥Â•Ω
                iLineNo: iAimLine,
                fPercent,
                durationStr, // sDuration_,
                sPosition: start_,
                iAll: This.aLineArr.length,
            };
        });
    }
    // ‚ñºÊâæÂà∞Ëµ∑ÂßãË°åÂè∑
    function getLeftStartIdx() {
        let {iCurLineIdx: idx, oRightToLeft} = This;
        const aKeys = Object.keys(oRightToLeft);
        if (!aKeys.length) return 0;
        while (idx--){
            if (!oRightToLeft[idx]) continue;
            const {iLeftLine} = oRightToLeft[idx];
            return iLeftLine; // ÊóßÁâàÔºöreturn Math.max(0, iLeftLine - 1);
        }
        return 0;
    }
    let iLastTimeChecked = -1;
    let isLastTimeGotResult = null;
    const wordsReExp = /\b[a-z0-9'-]+\b/ig;
    // ‚ñºËÆæÂÆö„ÄêÂ∑¶‰æßÊñáÊú¨„ÄëÁöÑÂΩìÂâçÂè•‰ΩçÁΩÆ
    async function setLeftLine(){
        const iLeftLines = This.aArticle.length;
        const willDo = iLeftLines && This.isShowLeft && This.leftType == 'txt';
        if (!willDo) return;
        // ‚ñº‰∏ãÊñπ2Ë°åÁöÑ‰ΩçÁΩÆ‰∏çÂèØÂêë‰∏ãÁßªÂä®
        This.iWriting = -1;
        Reflect.deleteProperty(This.oRightToLeft, This.iCurLineIdx);
        const text = This.oCurLine.text.trim();
        if (text.length < 1) return;
        const aPieces = text.match(wordsReExp); // Â∞ÜÂΩìÂâçÂè•ÂàÜÂâ≤
        if (!aPieces) return;
        // console.time('ËÄóÊó∂');
        // ‚ñºËæìÂÖ•ÁöÑ‰∏ä‰∏ÄË°åÊ≤°ÊúâÊàêÂäüÂåπÈÖçÊó∂Ôºå‰ºöÂèñÂà∞ -1 Âæà‰∏çÂ•Ω
        const {iLeftLine = -1, iMatchEnd: iLastMatchEnd} = This.oTopLineMatch || {}; // ÂèñÂæó‰πãÂâçÂåπÈÖçÂà∞ÁöÑ‰ΩçÁΩÆ‰ø°ÊÅØ
        // console.log("‰∏äÊ¨°ÂåπÈÖçÔºö", (This.oTopLineMatch || {}).$dc());
        const oResult = (()=>{
            const bLastTimeNoResult = !isLastTimeGotResult && (iLastTimeChecked == This.iCurLineIdx);
            const iStartFrom = bLastTimeNoResult ? 0 : getLeftStartIdx();
            for (let idx = iStartFrom; idx < iLeftLines; idx++ ){
                const sLeftFull = This.aArticle[idx]; 
                // if (sLeftFull.includes("xxx")) debugger;
                let iMatchStart = -1;
                let iLastMatch = idx == iLeftLine ? iLastMatchEnd : 0;
                const isInLine = aPieces.every(onePiece => {
                    const sLeftPiece = sLeftFull.slice(iLastMatch);
                    const oMatchInfo = sLeftPiece.match(new RegExp(onePiece.trim(), 'i'));
                    if (!oMatchInfo) return;
                    if (iMatchStart == -1) iMatchStart = oMatchInfo.index + (iLeftLine == idx ? iLastMatchEnd : 0);
                    iLastMatch += oMatchInfo.index + onePiece.length;
                    return true;
                });
                if (!isInLine) continue;
                return {
                    iWriting: idx,
                    iMatchStart,
                    iMatchEnd: iLastMatch,
                };
            }
        })();
        iLastTimeChecked = This.iCurLineIdx;
        isLastTimeGotResult = !!oResult;
        // console.timeEnd('ËÄóÊó∂');
        // console.log(`ÂÆö‰ΩçÂà∞Ë°å: ${oResult?.iWriting ?? 'Ê≤°ÊàêÂäü'} ---`);
        oResult && setLeftTxtTop(oResult);
    }
    // ‚ñºË∑≥ËΩ¨Âà∞ÁõÆÊ†áË°åÔºàÂ∞ÜÊù•Ë°•ÂÖÖÂä®ÁîªÊïàÊûúÔºâ
    async function setLeftTxtTop(obj){
        Object.assign(This, obj);
        This.oRightToLeft[This.iCurLineIdx] = {
            ...obj, iLeftLine: obj.iWriting,
        };
        await This.$nextTick();
        if (!This.oWritingLine) return;
        This.oWritingLine.scrollIntoView();
        // console.log('This.oWritingLine', This.oWritingLine); // ÂΩìÂâçË°åÁöÑ DOM ËäÇÁÇπ .offsetTop ÂèØÂæóÂà∞Âà∞È°∂ÈÉ®ÁöÑË∑ùÁ¶ª
        const maxVal = This.oLeftTxtWrap.scrollHeight - This.oLeftTxtWrap.offsetHeight;
        // console.log('‰∏çÂä®Ôºü', This.oLeftTxtWrap.scrollTop == maxVal);
        if (This.oLeftTxtWrap.scrollTop == maxVal) return;
        This.oLeftTxtWrap.scrollTop -= 190;
        // scrollTo
        // window.scrollTo({ top: 0, behavior: "smooth" });
        // ‚ñº https://zhuanlan.zhihu.com/p/438652229
        // requestAnimationFrame //  ÊòØ‰∏Ä‰∏™Êñ∞ÂÖ¥ÁöÑAPIÔºå‰∏ìÈó®‰∏∫ÊâßË°åÂä®ÁîªËÄåÁîüÔºåËøô‰∏™ÊñπÊ≥ïÊØèÁßí‰ºöÊâßË°å60Ê¨°ÔºåÂÖ∂ÂÆûËøô‰∏™60Âπ∂‰∏çÊòØÂõ∫ÂÆöÂÄºÔºåÂíåÂà∑Êñ∞ÁéáÊúâÂÖ≥Á≥ªÔºõ
    }
    // ‚ñºË∑≥Ë°åÂêéÂÆö‰Ωç‰∏ãÊñπÁöÑÊñáÊú¨‰ΩçÁΩÆÔºàoSententList => oSententWrapÔºâ
    function setLinePosition(iAimLine) {
        const { oSententWrap, iLineHeight } = This;
        const { scrollTop: sTop, offsetHeight: oHeight } = oSententWrap;
        const abloveCurLine = iAimLine * iLineHeight; // ÂΩìÂâçË°å‰∏äÊñπÁöÑÈ´òÂ∫¶
        oSententWrap.scrollTop = (() => {
            if (abloveCurLine < sTop + iLineHeight) {
                return abloveCurLine - iLineHeight;
            }
            // ‚ñ≤‰∏äÊñπË∂ÖÂá∫ÂèØËßÜÂå∫Ôºå‚ñº‰∏ãÊñπË∂ÖÂá∫ÂèØËßÜÂå∫Ôºà‰ª•‰∏ã‰ª£Á†ÅÊ≤°ËÉΩÊ∑±ÂàªÁêÜËß£Ôºâ
            if (abloveCurLine > sTop + oHeight - iLineHeight * 2) {
                return abloveCurLine - oHeight + iLineHeight * 2;
            }
            return sTop;
        })();
    }
    // ‚ñºÂæÆË∞ÉÂå∫ÂüüÔºà1ÂèÇÂèØËÉΩÊòØ start„ÄÅend„ÄÇ2ÂèÇÊòØË∞ÉÊï¥Ê≠•ÂπÖ
    function fixRegion(sKey, iDirection) {
        const { aLineArr, iCurLineIdx } = This;
        const oOld = aLineArr[iCurLineIdx];
        const previous = aLineArr[iCurLineIdx - 1];
        const next = aLineArr[iCurLineIdx + 1];
        let fNewVal = Math.max(0, oOld[sKey] + iDirection);
        if (previous && fNewVal < previous.end) {
            fNewVal = previous.end;
        }
        if (next && fNewVal > next.start) {
            fNewVal = next.start;
        }
        if (fNewVal > This.oMediaBuffer.duration + 0.5){
            return ElMessage.error('Ë∂ÖÂá∫Â§™Â§ö‰∫Ü');
        }
        setTime(sKey, fNewVal);
        recordHistory();
    }
    // ‚ñºËÆæÂÆöÊó∂Èó¥„ÄÇ1ÂèÇÊòØÁ±ªÂûãÔºå2ÂèÇÊòØÁßíÊï∞
    function setTime(sKey, fVal) {
        const { oCurLine } = This;
        const { start, end } = oCurLine;
        if (sKey === 'start' && fVal > end) { //Ëµ∑ÁÇπÂú®ÁªàÁÇπÂè≥‰æß
            oCurLine.start = end;
            oCurLine.end = fVal;
        } else if (sKey === 'end' && fVal < start) { // ÁªàÁÇπÂú®Ëµ∑ÁÇπÂ∑¶‰æß
            oCurLine.start = fVal;
            oCurLine.end = start;
        } else {
            oCurLine[sKey] = fVal;
        }
        This.aLineArr[This.iCurLineIdx] = fixTime(oCurLine);
    }
    // ‚ñºÊèíÂÖ•‰∏ÄÂè•„ÄÇ ÂèÇÊï∞ËØ¥ÊòéÔºö-1=ÂêëÂ∑¶Ôºå1=ÂêëÂè≥
    function toInsert(iDirection) {
        let { iCurLineIdx, aLineArr, oMediaBuffer, oMediaBuffer: { duration } } = This;
        const { start, end } = aLineArr[iCurLineIdx]; // ÂΩìÂâçË°å
        const isInsertToLeft = iDirection === -1; // true = ÂêëÂ∑¶ÊñπÈó¥ÈöôÊèíÂÖ•
        if (start < 0.1 && isInsertToLeft) return; // ‰Ωç‰∫éÊûÅÂ∑¶Ôºå‰∏çÂÜçÂêëÂ∑¶ÊèíÂÖ•
        // const oAim = aLineArr[iCurLineIdx + iDirection] || {}; // ÈÇªÂ±ÖÔºàÊóßÁâàÊú¨Ôºâ
        const oAim = aLineArr[iCurLineIdx + iDirection]; // ÈÇªÂ±Ö
        if (!oAim && iDirection==1 ){ // Áî®‰∫éÊµãËØï
            return previousAndNext(1);
        }
        const newIdx = isInsertToLeft ? iCurLineIdx : iCurLineIdx + 1;
        const iStart = (()=>{
            if (!isInsertToLeft) return end;
            return iCurLineIdx == 0 ? Math.max(0, start - 20) : oAim.end;
        })();
        const oNewLine = figureOut(oMediaBuffer, iStart);
        if (oNewLine.start === oNewLine.end) {
            return alert('ÊèíÂÖ•ÂèñÊ∂àÔºå‰ªÄ‰πàÊÉÖÂÜµ‰∏ã‰ºöÂà∞ËææËøôÈáåÔºü');
        }
        const {start: nlStart, end: nlEnd} = oNewLine; // nl = newLine
        if (isInsertToLeft){
            if (nlEnd > start) oNewLine.end = start - 0.1;
            if (nlStart >= oNewLine.end) oNewLine.start = Math.max(oAim.end + 0.1, oNewLine.end - 1);
        }else{
            if (nlEnd > oAim.start) oNewLine.end = oAim.start - 0.1;
            if (nlStart >= oNewLine.end) oNewLine.start = Math.max(end + 0.1, oNewLine.end - 1);
        }
        aLineArr.splice(newIdx, 0, oNewLine);
        if (!isInsertToLeft) This.iCurLineIdx++;
        recordHistory();
    }
    // ‚ñºÂà†Èô§ÊüêË°åÔºàÂΩìÂâçË°åÔºâ
    function toDel() {
        let { iCurLineIdx, aLineArr } = This;
        if (aLineArr.length <= 1) {
            return ElMessage.warning(`Ëá≥Â∞ë‰øùÁïô‰∏ÄË°å`);
        }
        const oDelAim = aLineArr[iCurLineIdx];
        if (oDelAim.id) {
            This.deletedSet.add(oDelAim.id);
        }
        aLineArr.splice(iCurLineIdx, 1);
        const iMax = aLineArr.length - 1;
        This.iCurLineIdx = Math.min(iMax, iCurLineIdx);
        goLine(This.iCurLineIdx);
        This.oMyWave.goOneLine(aLineArr[This.iCurLineIdx]);
        recordHistory();
    }
    // ‚ñºÂà∞ÊúÄÂêé‰∏ÄË°å
    function goLastLine() {
        const { aLineArr, iCurLineIdx, oTextArea } = This;
        let idx = aLineArr.findIndex(cur => {
            return cur.text.length <= 1;
        });
        if (idx === -1 || idx === iCurLineIdx) idx = aLineArr.length - 1;
        goLine(idx);
        oTextArea.focus();
        recordHistory();
    }
    // ‚ñºÈáçÊñ∞ÂÆö‰ΩçËµ∑ÁÇπÔºåÁªàÁÇπ
    function cutHere(sKey) {
        const { oAudio } = This.oMyWave;
        if (!oAudio) return;
        setTime(sKey, oAudio.currentTime);
        recordHistory();
    }
    // ‚ñºÊâ©ÈÄâ
    function chooseMore() {
        const { oMediaBuffer, oCurLine } = This;
        const newEnd = figureOut(oMediaBuffer, oCurLine.end, 0.35).end;
        setTime('end', newEnd);
        goLine();
        recordHistory();
    }
    // ‚ñºÂêàÂπ∂, -1‰∏ä‰∏ÄÂè•Ôºå1‰∏ã‰∏ÄÂè•
    function putTogether(iType) {
        const { iCurLineIdx, aLineArr } = This;
        const isIntoNext = iType === 1;
        const oCur = aLineArr[iCurLineIdx]; // ÂΩìÂâçËá™Â∑±Ë°åÔºàÂ∞ÜË¢´ÈîÄÊØÅ
        const oTarget = ({
            '-1': aLineArr[iCurLineIdx - 1], // Ë¶ÅÂπ∂ÂÖ•Âà∞‰∏ä‰∏ÄÊù°
            '1': aLineArr[iCurLineIdx + 1], // Ë¶ÅÂπ∂ÂÖ•Âà∞‰∏ã‰∏ÄÊù°
        }[iType]);
        if (!oTarget) return; //Ê≤°ÊúâÈÇªÂ±Ö‰∏çÂÜçÊâßË°å
        oTarget.start = Math.min(oTarget.start, oCur.start);
        oTarget.end = Math.max(oTarget.end, oCur.end);
        oTarget.text = (() => {
            const aResult = [oTarget.text];
            aResult[isIntoNext ? 'unshift' : 'push'](oCur.text);
            return aResult.join(' ').replace(/\s{2,}/g, ' ').trim();
        })();
        fixTime(oTarget);
        if (oCur.id >= 0) This.deletedSet.add(oCur.id); // ÈîÄÊØÅËá™Â∑±
        aLineArr.splice(iCurLineIdx, 1);
        if (!isIntoNext) This.iCurLineIdx--;
        recordHistory();
    }
    // ‚ñº‰∏ÄÂàÄ‰∏§Êñ≠ - 1ÂàÄ2Êñ≠
    function split() {
        // goLine(); // Âá∫Èîô‰∫ÜÔºöÂàá2Êñ≠ÁöÑÊó∂ÂÄôÂ∏∏ÂºπÂá∫‰øùÂ≠òÊèêÁ§∫Ôºå‰∏çÂ¶•ÔºàÂÅúÁî®ÊµãËØï‰∫é2022.07.23 18:3:2 ÊòüÊúüÂÖ≠Ôºâ
        const { aLineArr, iCurLineIdx, oCurLine, oMediaBuffer } = This;
        const { selectionStart } = This.oTextArea;
        const { currentTime } = This.oMyWave.oAudio;
        const { text, start, end} = oCurLine;
        const fLeftEndAt = aLineArr[iCurLineIdx -1]?.end || (start - 0.3);
        const fRightStartAt = aLineArr[iCurLineIdx +1]?.start || end;
        // const iGap01 = currentTime - start;
        // const fNextStart = aLineArr[iCurLineIdx+1]?.start;
        // const fRightLine = fNextStart ? fNextStart + 1 : end + 5;
        // const iGap02 = fRightLine - currentTime;
        const aNewItems = [
            fixTime({
                ...oCurLine,
                start: figureOut(oMediaBuffer, fLeftEndAt).start,
                end: currentTime,
                text: text.slice(0, selectionStart).trim(),
            }),
            fixTime({
                ...figureOut(oMediaBuffer, currentTime - 0.2), // , end-currentTime*0.6 // , 0.2, iGap02 + 2 
                text: text.slice(selectionStart).trim(),
            }),
        ];
        aNewItems[1].start = Math.max(aNewItems[1].start, currentTime);
        aNewItems[1].end = Math.min(aNewItems[1].end, fRightStartAt);
        Reflect.deleteProperty(aNewItems[1], 'id');
        aLineArr.splice(iCurLineIdx, 1, ...aNewItems);
        recordHistory();
    }
    // ‚ñºÊêúÁ¥¢
    function searchWord() {
        if (This.isShowDictionary) {
            This.isShowDictionary = false; // ÂÖ≥Èó≠Á™óÂè£
            return;
        }
        const sKey = window.getSelection().toString().trim() || '';
        // if (!sKey) return;
        console.log('ÊêúÁ¥¢Ôºö', sKey);
        This.sSearching = sKey;
        This.isShowDictionary = true;
    }
    // ‚ñº‰øùÂ≠òÁîüËØç ÔºàTODOÔºåÂàáÊç¢ËØçÁ±ªÂäüËÉΩÔºâ
    async function saveWord() {
        const word = window.getSelection().toString().trim() || '';
        if (!word) return;
        const wordReExp = new RegExp(`^${word}$`, 'i');
        const oExist = This.aWordsList.flat().find(cur => {
            return wordReExp.test(cur.word);
        });
        if (oExist) return This.changeWordType(oExist);
        const lengthOK = (word.length >= 2) && (word.length <= 30);
        if (!lengthOK) {
            return ElMessage.error(`ÂçïËØçÈïøÂ∫¶Â∫î >= 2 && <= 30`);
        }
        const res = await fnInvoke('db', 'saveOneNewWord', {
            word, mediaId: This.oMediaInfo.id,
        });
        if (!res) return ElMessage.error('‰øùÂ≠òÊú™ÊàêÂäü');
        // console.log('res\n', res);
        ElMessage.success('‰øùÂ≠òÊàêÂäü');
        This.getNewWords();
    }
    let inputTimer = null;
    let candidateTimer = null;
    // ‚ñºÂ§ÑÁêÜÁî®Êà∑ËæìÂÖ•
    function inputHandler(ev) {
        clearTimeout(inputTimer);
        clearTimeout(candidateTimer);
        const Backspace = ev.inputType == "deleteContentBackward";
        const isLetter = ev.data?.match(/[a-z]/i);
        // console.log('ËæìÂÖ•‰∫Ü =', ev.data);
        const iTimes = isLetter ? 300 : 0; // Â¶ÇÊûúËæìÂÖ•‰∫ÜÈùûÂ≠óÊØçÔºåÁ´ãÂç≥ÂåπÈÖçÂ∑¶‰æßÂ≠óÂπï
        inputTimer = setTimeout(()=>{
            recordHistory();
            setLeftLine();
        }, iTimes);
        // if (!oAlphabetObj[ev.data] && !Backspace) return;
        if (!isLetter && !Backspace) return;
        const sText = ev.target.value; // ÂΩìÂâçÊñáÂ≠ó
        const idx = ev.target.selectionStart; // ÂÖâÊ†á‰ΩçÁΩÆ
        // const sLeft = (sText.slice(0, idx) || '').split(' ').pop().trim();
        const sLeft = ((sText.slice(0, idx) || '').match(/[a-z]+/ig) || ['']).pop();
        This.sTyped = sLeft;
        // console.log('Â∑¶‰æßÊñáÊú¨Ôºö', sLeft);
        if (!sLeft) return;
        This.aCandidate = [];
        const sLeftLower = sLeft.toLowerCase();
        setCandidate(sLeftLower);
        candidateTimer = setTimeout(() => {
            setCandidate(sLeftLower, ++iSearchingQ);
        }, 600);
    }
    // ‚ñºÊü•ËØ¢ÂÄôÈÄâËØç
    async function setCandidate(sWord, iCurQs) {
        const aResult = [];
        for (const cur of This.aFullWords) {
            if (cur.toLowerCase().startsWith(sWord)) {
                aResult.push(cur);
            }
            if (aResult.length >= 4) break;
        }
        // console.log('ÂÄôÈÄâËØçÔºö', aResult.$dc());
        This.aCandidate = aResult;
        if (typeof iCurQs != 'number') return;
        // const aWords = await fnInvoke('db', 'getCandidate', {
        //     sWord, limit: 9 - aResult.length,
        // });
        console.time('Êü•Â≠óÂÖ∏');
        let aWords = sqlite.select(`
            select word
            from dictionary
            where word like '${sWord}%'
            limit ${9 - aResult.length}
        `);
        console.timeEnd('Êü•Â≠óÂÖ∏');
        aWords &&= aWords.map(cur=>cur.word);
        console.log("aWords", aWords);
        if (!aWords || iCurQs != iSearchingQ) return;
        This.aCandidate.push(...aWords);
    }
    
    // ‚ñºÊèíÂÖ•ÈÄâ‰∏≠ÁöÑÂçïËØç
    async function toInset(idx) {
        const { sTyped, aCandidate, oTextArea } = This;
        const theWord = (aCandidate[idx] || '').slice(sTyped.length);
        if (!theWord) return;
        const { text } = This.oCurLine;
        const cursorIdx = oTextArea.selectionStart; // Ë°®Á§∫ÂÖâÊ†áÂ∑¶ÊúâÂá†‰∏™ÂçïËØç
        const left = text.slice(0, cursorIdx);
        const right = text.slice(cursorIdx);
        const newLeft = (left + theWord);
        This.oCurLine.text = (newLeft + right).trim();
        recordHistory();
        await This.$nextTick();
        oTextArea.selectionStart = newLeft.length;
        oTextArea.selectionEnd = newLeft.length;
    }
    // ‚ñºÊäõÂºÉÂΩìÂâçË°åÔºåÊàñÂ§ÑÁêÜÁ¨¨‰∏ÄË°å
    function giveUpThisOne(start) {
        start = start || This.oCurLine.end;
        const { oMediaBuffer } = This;
        const oNextLine = figureOut(oMediaBuffer, start); //ËøîÂõû‰∏ã‰∏ÄË°åÁöÑÊï∞ÊçÆ
        This.aLineArr[This.iCurLineIdx] = {
            ...This.aLineArr[This.iCurLineIdx], // ‰øùÁïôÊóßÁöÑID
            ...oNextLine,
        };
        recordHistory();
        This.oMyWave.goOneLine(oNextLine);
    }
    // ‚ñº‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
    async function saveLines() {
        if (isSavingToDB) return; // Èò≤Êäñ
        const toSaveArr = [];
        const mediaId = This.oMediaInfo.id;
        This.aLineArr.forEach(cur => {
            This.deletedSet.delete(cur.id); // Èò≤Ê≠¢ËØØÂà†
            if (!This.checkIfChanged(cur)) return; // Ê≤°ÂèòÂä®‰∏çÂà†Èô§
            ['start', 'end'].forEach(key => {
                cur[key] = Number.parseFloat(cur[key].toFixed(2));
            });
            toSaveArr.push({ ...cur, mediaId }); // mediaId ÁöÑÁî®ÈÄîÊòØÊ†áËÆ∞Ê≠§Ë°åÊâÄÂ±ûÁöÑÂ™í‰Ωì
        });
        const toDelArr = [...This.deletedSet];
        if (!toSaveArr.length && !toDelArr.length) {
            return ElMessage.warning(`Ê≤°Êúâ‰øÆÊîπÔºåÊó†Ê≥ï‰øùÂ≠ò`);
        }
        console.time('‰øùÂ≠ò‰∏éÊü•ËØ¢ËÆ°Êó∂');
        isSavingToDB = true;
        // console.log('Â∞Ü‰øùÂ≠òÂ≠óÂπïÔºö\n', toSaveArr, toDelArr);
        const oResult = await LineDB.updateMediaLines({
            toSaveArr,
            toDelArr,
            isReturnAll: true,
            mediaId,
        }).catch(err=>{
            console.log('‰øùÂ≠òÂ§±Ë¥•\n', err);
            alert('‰øùÂ≠òÂ§±Ë¥•');
        });
        console.timeEnd('‰øùÂ≠ò‰∏éÊü•ËØ¢ËÆ°Êó∂');
        if (!oResult) {
            isSavingToDB = false;
            return;
        }
        console.log("‰øùÂ≠òÁªìÊûú", oResult);
        afterSaved(oResult); // Âú®ÂÖ∂ÂÜÖÊâßË°å isSavingToDB = false;
        saveInDx();
        // isSavingToDB = false;
    }
    // üëá‰øùÂ≠òÂà∞ dxDB
    async function saveInDx(){
        const sqlite = await useSqlite;
        console.time('ÊâßË°å-sqlite.export()');
        const exported = sqlite.export(); // Uint8Array
        console.timeEnd('ÊâßË°å-sqlite.export()');
        console.time('ÊâßË°å-new Blob()');
        const myBlob = new Blob([exported]);
        console.timeEnd('ÊâßË°å-new Blob()');
        await dxDB.sqlite.clear();
        // console.time('ÊâßË°å-‰øùÂ≠òÂà∞ dxDB');
        dxDB.sqlite.add({ // ËÄóÊó∂Â∞è‰∫é 1ms
            time: new Date().toLocaleString(),
            data: myBlob,
        });
        // console.timeEnd('ÊâßË°å-‰øùÂ≠òÂà∞ dxDB');
    }
    function afterSaved(oResult){
        // ‚ñº Âä†ËΩΩÊñ∞Â≠óÂπï
        This.getLinesFromDB(oResult.newRows).then(res=>{
            isSavingToDB = false;
        });
        ElMessage.success(`
            ÊàêÂäüÔºöÂ∑≤‰øÆÊîπ ${oResult.save} Êù°ÔºåÂà†Èô§ ${oResult.delete} Êù°
        `.trim());
        This.deletedSet.clear();
        // This.oTodayBar.init();
    }
    // ‚ñºÊí§ÈîÄ-ÊÅ¢Â§ç
    function setHistory(iType) {
        const { length } = This.aHistory;
        const iCurStep = This.iCurStep + iType;
        console.log(`${iType == 1 ? 'Go' : 'Back'}To ->`, iCurStep);
        if (iCurStep < 0 || iCurStep > length - 1) {
            const actionName = ({
                '-1': 'Ê≤°Êúâ‰∏ä‰∏ÄÊ≠•ÁöÑÊï∞ÊçÆÔºåÊó†Ê≥ïÊí§ÈîÄ',
                '1': 'Â∑≤Ê≤°Êúâ‰∏ã‰∏ÄÊ≠•ÁöÑÊï∞ÊçÆ',
            }[iType]);
            return ElMessage.error(actionName);
        }
        const oHistory = This.aHistory[iCurStep];
        const aLineArr = JSON.parse(oHistory.sLineArr);
        // const notSameLine = This.iCurStep != iCurStep;
        This.iCurStep = iCurStep;
        This.aLineArr = aLineArr;
        This.iCurLineIdx = oHistory.iCurLineIdx; // ÁΩÆ‰∫éÊúÄÂêé‰∏ÄË°å
        This.oMyWave.goOneLine(This.oCurLine);
    }
    // ‚ñº‰øùÂ≠ò‰∏ÄÊù°ÂéÜÂè≤ËÆ∞ÂΩï
    let isSaving = false;
    function recordHistory() {
        if (isSaving) return console.log('‚òÖ‰øùÂ≠òÂéÜÂè≤-Èò≤ÊäñÊàêÂäü‚òÖ');
        isSaving = true;
        const sLineArr = JSON.stringify(This.aLineArr);
        This.aHistory.splice(This.iCurStep + 1, Infinity, {
            sLineArr,
            iCurLineIdx: This.iCurLineIdx,
        });
        This.iCurStep = Math.min(This.iCurStep + 1, This.iHisMax - 1);
        if (This.aHistory.length <= This.iHisMax) {
            return (isSaving = false);
        }
        This.aHistory.shift();
        isSaving = false;
    }
    // ‚ñºÊúÄÁªàËøîÂõû
    return {
        setTime,
        previousAndNext,
        goLine,
        fixRegion,
        toInsert,
        toDel,
        goLastLine,
        cutHere,
        chooseMore,
        putTogether,
        split,
        searchWord,
        saveWord,
        inputHandler,
        toInset,
        giveUpThisOne,
        saveLines,
        setHistory,
        setLeftLine,
        dealQuotationMark,
        smartFill,
        readAloud,
        readingStopped,
        Esc,
        tts_reader,
    };
}

// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
// ‰ª•‰∏ãÊòØÊóßÁΩëÁ´ôÁöÑÊñπÊ≥ï

class keyDownFn {
    // ‚ñº ËæìÂÖ•Ê°ÜÊñáÂ≠óÊîπÂèò
    valChanged(ev) {
        clearTimeout(this.typeingTimer);
        const sText = ev.target.value; // ÂΩìÂâçÊñáÂ≠ó
        if (/\n/.test(sText)) return this.previousAndNext(1, true);
        const idx = ev.target.selectionStart;
        const sLeft = sText.slice(0, idx);
        let sTyped = ''; // ÂçïËØçÂºÄÂ§¥ÔºàÁî®‰∫éÊêúÁ¥¢ÁöÑÔºâ
        if (sLeft.endsWith(' ')) { // ËøõÂÖ•Âà§Êñ≠ sTyped ‰∏ÄÂÆöÊòØÁ©∫Â≠óÁ¨¶
            // Â¶ÇÊûúÈîÆÂÖ•‰∫Ü„ÄêÈùû„ÄëËã±ÊñáÂ≠óÊØçÔºå„ÄêÈúÄË¶Å„ÄëÁîüÊàêÊñ∞ÂéÜÂè≤
            this.saveHistory({
                aLineArr: this.state.aLineArr,
                iCurLineIdx: this.state.iCurLineIdx,
                sCurLineTxt: sText,
            });
        } else {
            // Ëã±ÊñáÂ≠óÊØçÁªìÂ∞æÔºå„Äê‰∏çË¶Å„ÄëÁîüÊàêÊñ∞ÂéÜÂè≤
            const sRight = sText.slice(idx);
            const needToCheck = /\b[a-z]{1,20}$/i.test(sLeft) && /^(\s*|\s+.+)$/.test(sRight);
            if (needToCheck) sTyped = sLeft.match(/\b[a-z]+$/gi).pop();
        }
        this.setState({
            sTyped, sCurLineTxt: sText,
        });
        this.getMatchedWords(sTyped);
    }
}

// SELECT * 
// FROM "line" 
// where id = 100718
// start 69.1400000000001
// sqlite ÊãÜÂàÜÂ≠óÁ¨¶ÔºåÂ≠óÁ¨¶ÂàÜÂàóÔºåÂàÜÂâ≤Â≠óÁ¨¶
// length(substr(start, instr(start, '.') + 1)) > 2
// substr(start, 0, instr(start, '.')),
// substr(start, instr(start, '.') + 1)
// length(substr(start, instr(start, '.') + 1)) as len,

